// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/common/ERC2981.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
// import "../common/interface/IERC4907.sol";
import "../accessmaster/interfaces/IAccessMaster.sol";

/// @title PhygitalA: A Smart Contract for Managing Phygital Assets with ERC721 Tokens
/**
 * @dev This contract manages phygital (physical + digital) assets through NFTs. It supports minting, renting,
 * and tracking of physical items' digital representations. The contract integrates ERC721A for efficient
 * batch minting, ERC2981 for royalty management, and IERC4907 for rentable NFTs.
 * It allows for the immutable registration of NFC IDs to NFTs, ensuring a unique and verifiable link
 * between a physical item and its digital counterpart.
 */
// contract Phygital is Context, ERC721Enumerable, ERC2981, IERC4907 {
contract Phygital is Context, ERC721Enumerable, ERC2981 {
    // Set Constants for Interface ID and Roles
    bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;

    using Strings for uint256;

    address public tradeHub;
    address public accessMasterAddress;

    uint8 public constant version = 1;

    uint256 public nftPrice;
    uint256 public Counter;

    enum ItemStatus {
        DESTROYED,
        DAMAGED,
        REPAIRED,
        RESALE,
        INUSE,
        ORIGINAL
    }

    struct PhygitalInfo {
        uint256 registerTime;
        bytes phygitalId;
        ItemStatus status;
    }

    struct RentableItems {
        bool isRentable; //to check is renting is available
        address user; // address of user role
        uint64 expires; // unix timestamp, user expires
        uint256 hourlyRate; // amountPerHour
    }

    ///@dev storing the data of the user who are renting the NFT
    mapping(uint256 => RentableItems) public rentables;

    // Optional mapping for token URIs
    mapping(uint256 => string) private _tokenURIs;

    mapping(uint256 => PhygitalInfo) public phygitalAssets;

    mapping(bytes => bool) public phygitalIdCheck;

    IACCESSMASTER flowRoles;

    modifier onlyOperator() {
        require(
            flowRoles.isOperator(_msgSender()),
            "Phygital: User is not authorized "
        );
        _;
    }

    modifier onlyCreator() {
        require(
            flowRoles.isCreator(_msgSender()),
            "Phygital: User is not authorized"
        );
        _;
    }

    event PhygitalAssetCreated(
        uint256 tokenID,
        address indexed creator,
        string metaDataURI
    );

    event PhygitalAssetDestroyed(uint indexed tokenId, address ownerOrApproved);

    event RentalInfo(
        uint256 tokenId,
        bool isRentable,
        uint256 price,
        address indexed renter
    );

    event FundTransferred(
        address sender,
        address reciepient,
        uint256 tokenId,
        uint256 amount
    );

    event UpdateAssetStatus(address user, ItemStatus assetStatus, uint256 time);

    /**
     * @dev Grants `FLOW_ADMIN_ROLE`, `FLOW_CREATOR_ROLE` and `FLOW_OPERATOR_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    constructor(
        string memory name,
        string memory symbol,
        address tradeHubAddress,
        address accessControlAddress
    ) ERC721(name, symbol) {
        flowRoles = IACCESSMASTER(accessControlAddress);
        tradeHub = tradeHubAddress;
        accessMasterAddress = accessControlAddress;
    }

    function setItemStatus(uint256 tokenId, ItemStatus _status) external {
        require(
            flowRoles.isOperator(_msgSender()) ||
                ownerOf(tokenId) == _msgSender(),
            "Phygital: User is not authorised!"
        );

        phygitalAssets[tokenId].status = _status;

        emit UpdateAssetStatus(_msgSender(), _status, block.timestamp);
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_safeMint}.
     *
     * Requirements:
     *
     * - the caller must have the `FLOW_CREATOR_ROLE`.
     */
    function createAsset(
        string memory metadataURI,
        uint96 royaltyPercentBasisPoint,
        bytes memory _phygitalID
    ) public onlyCreator returns (uint256) {
        // We cannot just use balanceOf to create the new tokenId because tokens
        // can be burned (destroyed), so we need a separate counter.
        require(
            !phygitalIdCheck[_phygitalID],
            "Phygital: Tag is already stored!"
        ); // instead of phygital use NFC
        Counter++;
        uint256 currentTokenID = Counter;

        phygitalAssets[currentTokenID] = PhygitalInfo(
            block.timestamp,
            _phygitalID,
            ItemStatus.ORIGINAL
        );

        phygitalIdCheck[_phygitalID] = true;

        _safeMint(_msgSender(), currentTokenID);
        _setTokenURI(currentTokenID, metadataURI);
        // Set royalty Info
        require(
            royaltyPercentBasisPoint <= 1000,
            "Phygital: Royalty can't be more than 10%"
        );
        _setTokenRoyalty(
            currentTokenID,
            _msgSender(),
            royaltyPercentBasisPoint
        );
        // Approve tradeHub to transfer NFTs
        setApprovalForAll(tradeHub, true);

        emit PhygitalAssetCreated(currentTokenID, _msgSender(), metadataURI);
        return currentTokenID;
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_safeMint}.
     *
     * Requirements:
     *
     * - the caller must have the `FLOW_CREATOR_ROLE`.
     */
    function delegateAssetCreation(
        address creator,
        string memory metadataURI,
        uint96 royaltyPercentBasisPoint,
        bytes memory phygitalID
    ) public onlyOperator returns (uint256) {
        // We cannot just use balanceOf to create the new tokenId because tokens
        // can be burned (destroyed), so we need a separate counter.
        require(
            !phygitalIdCheck[phygitalID],
            "Phygital: NFC Tag is already stored!"
        );
        Counter++;
        uint256 currentTokenID = Counter;

        phygitalAssets[currentTokenID] = PhygitalInfo(
            block.timestamp,
            phygitalID,
            ItemStatus.ORIGINAL
        );

        phygitalIdCheck[phygitalID] = true;

        _safeMint(creator, currentTokenID);
        _setTokenURI(currentTokenID, metadataURI);

        // Set royalty Info
        require(
            royaltyPercentBasisPoint <= 1000,
            "Phygital: Royalty can't be more than 10%"
        );
        _setTokenRoyalty(currentTokenID, creator, royaltyPercentBasisPoint);

        // Approve tradeHub to transfer NFTs
        setApprovalForAll(tradeHub, true);

        emit PhygitalAssetCreated(currentTokenID, creator, metadataURI);
        return currentTokenID;
    }

    /**
     * @notice Burns `tokenId`. See {ERC721-_burn}.
     *
     * @dev Requirements:
     *
     * - The caller must own `tokenId` or be an approved operator.
     */
    function destroyAsset(uint256 tokenId) public {
        require(
            ownerOf(tokenId) == _msgSender() ||
                flowRoles.isOperator(_msgSender()),
            "Phygital: Caller is not token owner or approved"
        );
        require(
            phygitalAssets[tokenId].status == ItemStatus.DESTROYED,
            "Phygital: Cannot be burned"
        );
        _burn(tokenId);
        emit PhygitalAssetDestroyed(tokenId, _msgSender());
        _resetTokenRoyalty(tokenId);
    }

    /**
     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function _setTokenURI(
        uint256 tokenId,
        string memory _tokenURI
    ) internal virtual {
        require(
            _requireOwned(tokenId) == _msgSender(),
            "Phygital: Non-Existent Asset"
        );
        _tokenURIs[tokenId] = _tokenURI;
    }

    /********************* Rental(ERC4907) *********************************/
    /// @notice Owner can set the NFT's rental price and status
    // function setRentInfo(
    //     uint256 tokenId,
    //     bool isRentable,
    //     uint256 pricePerHour
    // ) public {
    //     require(
    //         _isAuthorized(_ownerOf(tokenId), _msgSender(), tokenId),
    //         "Phygital: Caller is not token owner or approved"
    //     );
    //     rentables[tokenId].isRentable = isRentable;
    //     rentables[tokenId].hourlyRate = pricePerHour;
    //     emit RentalInfo(tokenId, isRentable, pricePerHour, _msgSender());
    // }

    // /// @notice set the user and expires of an NFT
    // /// @dev This function is used to gift a person by the owner,
    // /// The zero address indicates there is no user
    // /// Throws if `tokenId` is not valid NFT
    // /// @param user  The new user of the NFT
    // /// @param expires  UNIX timestamp, The new user could use the NFT before expires

    // function setUser(uint256 tokenId, address user, uint64 expires) public {
    //     require(
    //         _requireOwned(tokenId) == _msgSender(),
    //         "Phygital: Not token owner Or approved"
    //     );
    //     require(
    //         userOf(tokenId) == address(0),
    //         "Phygital: item is already subscribed"
    //     );
    //     RentableItems storage info = rentables[tokenId];
    //     info.user = user;
    //     info.expires = expires + uint64(block.timestamp);
    //     emit UpdateUser(tokenId, user, info.expires);
    // }

    // /**
    //  * @notice to use for renting an item
    //  * We are calculating 1 month equal to 30 days
    //  * @dev The zero address indicates there is no user renting the item currently
    //  * Throws if `tokenId` is not valid NFT,
    //  * time cannot be less than 1 hour or more than 6 months
    //  * @param _timeInHours  is in hours , Ex- 1,2,3
    //  */

    // function rent(uint256 _tokenId, uint256 _timeInHours) external payable {
    //     require(
    //         _requireOwned(_tokenId) == _msgSender(),
    //         "Phygital: Invalide Token Id"
    //     );
    //     require(
    //         rentables[_tokenId].isRentable,
    //         "Phygital: Not available for rent"
    //     );
    //     require(
    //         userOf(_tokenId) == address(0),
    //         "Phygital: NFT Already Subscribed"
    //     );
    //     require(_timeInHours > 0, "Phygital: Time can't be less than 1 hour");
    //     require(
    //         _timeInHours <= 4320,
    //         "Phygital: Time can't be more than 6 months"
    //     );

    //     uint256 amount = amountRequired(_tokenId, _timeInHours);

    //     require(msg.value >= amount, "Phygital: Insufficient Funds");
    //     payable(ownerOf(_tokenId)).transfer(msg.value);

    //     RentableItems storage info = rentables[_tokenId];
    //     info.user = _msgSender();
    //     info.expires = uint64(block.timestamp + (_timeInHours * 3600));
    //     emit UpdateUser(_tokenId, _msgSender(), info.expires);
    // }

    /** Getter Functions **/

    /************* Rental(ERC4907) ***************** */
    /// @dev IERC4907 implementation
    // function userOf(uint256 tokenId) public view returns (address) {
    //     if (userExpires(tokenId) >= block.timestamp) {
    //         return rentables[tokenId].user;
    //     } else {
    //         return address(0);
    //     }
    // }

    // /// @dev IERC4907 implementation
    // function userExpires(uint256 tokenId) public view returns (uint256) {
    //     return rentables[tokenId].expires;
    // }

    // /// @notice to calculate the amount of money required
    // /// to rent an item for a certain time
    // function amountRequired(
    //     uint256 tokenId,
    //     uint256 time
    // ) public view returns (uint256 amount) {
    //     amount = rentables[tokenId].hourlyRate * time;
    // }

    /////////////////////////////////////////////////

    /**
     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
     */
    function tokenURI(
        uint256 tokenId
    ) public view virtual override returns (string memory) {
        require(
            _requireOwned(tokenId) == _msgSender(),
            "SignatureSeries: Non-Existent Asset"
        );
        string memory _tokenURI = _tokenURIs[tokenId];

        return _tokenURI;
    }

    // function _update(
    //     address to,
    //     uint256 tokenId,
    //     address auth
    // ) internal virtual override returns (address) {
    //     address from = super._update(to, tokenId, auth);
    //     if (from != to && rentables[tokenId].user != address(0)) {
    //         delete rentables[tokenId];
    //         emit UpdateUser(tokenId, address(0), 0);
    //     }
    //     return from;
    // }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(
        bytes4 interfaceId
    ) public view virtual override(ERC721Enumerable, ERC2981) returns (bool) {
        if (interfaceId == _INTERFACE_ID_ERC2981) return true;
        // if (interfaceId == type(IERC4907).interfaceId) return true;
        return super.supportsInterface(interfaceId);
    }
}
